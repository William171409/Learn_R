---
title: "Option trading - dynamic hedging"
subtitle: "FN6901 Group Assignment"
author: 
  - "Team A"
  - "Author: XU SHUMING"
  - "Reviewer1: WANG QIANTENG"
  - "Reviewer2: HU ZIHAO"
output:
    html_document: 
      toc: yes
      toc_float: true
      theme: lumen
editor_options:
    markdown:
        wrap: 72
---

```{r setup, include=FALSE}
library(purrr)
library(tidyverse)
library(NMOF)
```

```{r, include = TRUE}
##While daily operations appear profitable, the overall strategy results in a loss. Possible reasons include market volatility and unfavorable strike price dynamics. Further analysis of volatility, strike selection, or holding strategies may help improve outcomes.
```

# 0. Set Seed and Constants

```{r}
set.seed(314123)
# Define parameters
num_sim<-1000
S <- 100        # Initial price
K <- 100        # Strike price
sigma_rel <- 0.3    # Realized volatility
sigma_imp <- 0.3    # Implied volatility
r_val <- 0      # Risk-free rate
q_val <- 0      # Dividend yield
timestep <- 1 / 250  # One day as a fraction of a year
days <- 20      # 20-day simulation

# Drift and volatility adjustments
p1 <- (r_val - q_val - 0.5 * sigma_rel^2) * timestep
p2 <- sigma_rel * sqrt(timestep)
```

# 1. Define Function to Run Option PnL Simulation

```{r}
# Function to simulate option PnL
simulate_option_pnl <- function(number_of_simulations, S, K, sigma_rel, sigma_imp, r_val, q_val, timestep, days, p1, p2) {
  
  # Input validation GENERATED BY ChatGPT
  # stopifnot(is.numeric(number_of_simulations) && number_of_simulations > 0, "number_of_simulations must be a positive number")
  # stopifnot(is.numeric(S) && S > 0, "S must be a positive number")
  # stopifnot(is.numeric(K) && K > 0, "K must be a positive number")
  # stopifnot(is.numeric(sigma_rel) && sigma_rel > 0, "sigma_rel must be a positive number")
  # stopifnot(is.numeric(sigma_imp) && sigma_imp > 0, "sigma_imp must be a positive number")
  # stopifnot(is.numeric(r_val), "r_val must be numeric")
  # stopifnot(is.numeric(q_val), "q_val must be numeric")
  # stopifnot(is.numeric(timestep) && timestep > 0, "timestep must be a positive number")
  # stopifnot(is.numeric(days) && days > 0, "days must be a positive number")
  # stopifnot(is.numeric(p1), "p1 must be numeric")
  # stopifnot(is.numeric(p2) && p2 > 0, "p2 must be a positive number")
  
  # Core Simulation Logic
  sim_results <- map_dfr(1:number_of_simulations, function(dummy) {
    # Generate the price path (log-normal)
    ss <- c(S, rep(S, days) * cumprod(rlnorm(days, mean = p1, sd = p2)))
    
    # Create a dataframe for storing option prices and Greeks
    df <- tibble(S = ss, days = days:0, var = sigma_imp * sigma_imp, strike = K)
    
    # Calculate option price, delta, gamma, and theta for each day
    opt <- rowwise(df) %>%
      mutate(
        result = ifelse(
          days == 0,
          # Handle expiry (tau = 0) separately
          list(list(value = max(S - strike, 0), delta = 0, gamma = 0, theta = 0, vega = 0)),
          list(vanillaOptionEuropean(S = S, X = strike, tau = days / 250, r = r_val, q = q_val, v = var, type = "call", greeks = TRUE))
        ),
        price = result$value,
        delta = result$delta,
        gamma = result$gamma,
        theta = result$theta,
        vega = result$vega
      ) %>%
      ungroup()
    
    # Calculate the total PnL from Day 0 to Day 20
    option_PnL <- opt$price[days + 1] - opt$price[1]
    
    # Calculate sum of Gamma, Delta, and Theta contributions (sum of daily values)
    gamma_PnL <- sum(0.5 * opt$gamma[1:length(diff(opt$S))] * (diff(opt$S)^2))
    delta_PnL <- sum(opt$delta[1:length(diff(opt$S))] * diff(opt$S))
    theta_PnL <- sum(opt$theta * timestep)
    
    # Return the necessary values as a tibble
    return(tibble(
      option_PnL = option_PnL,
      gamma_PnL = gamma_PnL,
      delta_PnL = delta_PnL,
      theta_PnL = theta_PnL,
      vega_PnL = 0,# Since Vega is constant in your case
      vega0 = opt$vega[1]
      # option_premium = opt$price[1],
      # option_payoff = opt$price[days+1]
      ))
  })
  
  # Return simulation results
  return(sim_results)
}

```

# 2. Run Simulations

```{r}
(sim_result <- simulate_option_pnl(
  number_of_simulations = num_sim, 
  S = S, 
  K = K, 
  sigma_rel = sigma_rel, 
  sigma_imp = sigma_imp, 
  r_val = r_val, 
  q_val = q_val, 
  timestep = timestep, 
  days = days, 
  p1 = p1, 
  p2 = p2
))
```

# 3. Analysis

## 3.1 Approximation of PnL by Taylor Expansion

1.  The sum of daily Taylors expansion is a close approximation to
    option PnL (which is the difference between option price on day 20
    and option price on day 0).

```{r}
sim_result %>%
  summarize(
    Taylor_approx = mean(gamma_PnL + theta_PnL+delta_PnL+vega_PnL),
    Option_PnL = mean(option_PnL),
    Difference = mean(option_PnL) - mean(gamma_PnL + theta_PnL+delta_PnL+vega_PnL)
  )
```

## 3.2 Gamma & Theta Neutralization

2.  When realized volatility and implied volatility are the same, Gamma
    and Theta can neutralize each other,
    i.e. $\sum_{i}^{N}(GammaPnL_i + ThetaPnL_i) \approx 0$

```{r}
sim_result %>%
  summarize(
    Gamma_Theta_Sum = mean(gamma_PnL + theta_PnL)
  )
```

## 3.3 Approximation of Sell Side PnL by Vega

3.  When implied volatility used to price the option is set to 0.5, but
    the realized volatility to generate simulated path is 0.3. The PnL
    from the sell side $PnL≈(Vol_{imp}−Vol_{Rel})Vega_0$. The PnL from
    sell side = the premium of the option + option payoff at expiry +
    delta hedging PnL. We assume zero transaction fee. Be aware that the
    sell side shall fulfill option payoff to the client.

```{r}
(sim_result <- simulate_option_pnl(
  number_of_simulations = num_sim, 
  S = S, 
  K = K, 
  sigma_rel = sigma_rel, 
  sigma_imp = 0.5, 
  r_val = r_val, 
  q_val = q_val, 
  timestep = timestep, 
  days = days, 
  p1 = p1, 
  p2 = p2
))
```

```{r}
sim_result %>%
  summarize(
    Sell_PnL = mean(delta_PnL-option_PnL),
    estimated_Sell_PnL = mean(vega0)*0.2
  )
```
